(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{514:function(a,t,_){"use strict";_.r(t);var v=_(2),r=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"服务拆分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务拆分"}},[a._v("#")]),a._v(" 服务拆分")]),a._v(" "),t("h2",{attrs:{id:"分解步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分解步骤"}},[a._v("#")]),a._v(" 分解步骤")]),a._v(" "),t("h3",{attrs:{id:"_1-定义系统操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义系统操作"}},[a._v("#")]),a._v(" 1. 定义系统操作")]),a._v(" "),t("p",[a._v("系统操作代表一个应用请求的程序必须处理的外部请求, 系统操作是一种抽象描述.")]),a._v(" "),t("p",[a._v("定义系统操作从需求开始, 往往是用户故事.")]),a._v(" "),t("p",[a._v("两步式流程识别与定义系统操作:")]),a._v(" "),t("ul",[t("li",[a._v("创建由关键类组成的抽象领域模型, 这些类用于描述系统操作的词汇表")]),a._v(" "),t("li",[a._v("确定系统操作, 根据领域模型描述系统操作的行为")])]),a._v(" "),t("h3",{attrs:{id:"_2-定义服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-定义服务"}},[a._v("#")]),a._v(" 2. 定义服务")]),a._v(" "),t("ul",[t("li",[a._v("定义域业务能力相对应的服务")]),a._v(" "),t("li",[a._v("围绕DD子域来分解和设计服务")])]),a._v(" "),t("h3",{attrs:{id:"_3-定义服务api和协作方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-定义服务api和协作方式"}},[a._v("#")]),a._v(" 3. 定义服务API和协作方式")]),a._v(" "),t("ul",[t("li",[a._v("将系统操作分配给服务, 服务可以完全独立的实现操作")]),a._v(" "),t("li",[a._v("分别确定那些系统操作单独服务可以处理, 那些需要相互协作")])]),a._v(" "),t("h2",{attrs:{id:"服务分解障碍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务分解障碍"}},[a._v("#")]),a._v(" 服务分解障碍")]),a._v(" "),t("h3",{attrs:{id:"网络延迟"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络延迟"}},[a._v("#")]),a._v(" 网络延迟")]),a._v(" "),t("blockquote",[t("p",[a._v("维护服务间的同步通信降低可用性")]),a._v(" "),t("p",[a._v("服务间网络往返过多")])]),a._v(" "),t("p",[a._v("解决方式: "),t("strong",[a._v("自包含服务")]),a._v(" : 服务不依赖服务, 能够以独立的方式供外部使用")]),a._v(" "),t("h3",{attrs:{id:"跨服务的数据一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跨服务的数据一致性"}},[a._v("#")]),a._v(" 跨服务的数据一致性")]),a._v(" "),t("p",[a._v("微服务一致性要求内刚外柔: 服务内聚合通过数据库事务保证一致性, 服务外要求保证最终一致")]),a._v(" "),t("ul",[t("li",[a._v("Saga")]),a._v(" "),t("li",[a._v("两段式提交")]),a._v(" "),t("li",[a._v("三段式提交")])]),a._v(" "),t("h3",{attrs:{id:"上帝类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#上帝类"}},[a._v("#")]),a._v(" 上帝类")]),a._v(" "),t("p",[a._v("采用DDD并将每个服务视为具有自己的领域模型的单独子域, 所有与上帝类有关的服务都有自己的领域模型及其对应的上帝类的版本, 如Order.")]),a._v(" "),t("p",[a._v("每个领域模型中的Order类标示统一Order业务实体的不同方面, 应用程序必须维护不同服务中的这些对象之间的一致性.")]),a._v(" "),t("h3",{attrs:{id:"进程间通讯造成可用性降低"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程间通讯造成可用性降低"}},[a._v("#")]),a._v(" 进程间通讯造成可用性降低")]),a._v(" "),t("p",[a._v("可以通过异步消息的方式解决")]),a._v(" "),t("h3",{attrs:{id:"获取一致性视图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取一致性视图"}},[a._v("#")]),a._v(" 获取一致性视图")]),a._v(" "),t("p",[a._v("单独创建一个QueryService, 同步CQRS更新视图")])])}),[],!1,null,null,null);t.default=r.exports}}]);